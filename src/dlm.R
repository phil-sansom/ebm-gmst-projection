###########################
## Dynamic Linear Models ##
###########################

# filter.dlm = function(y, F, G, V, W, c, d, m0, C0) {
#   
#   ## Dimensions
#   tt = ncol(y)  ## Length of observation vector
#   rr = nrow(y)  ## Dimension of observation vector
#   nn = ncol(F)  ## Length of state vector
# 
#   ## Create arrays to store results
#   a  = array(NA, dim = c(nn,   tt))  ## state prior mean
#   R  = array(NA, dim = c(nn,nn,tt))  ## state prior scale
#   f  = array(NA, dim = c(rr,   tt))  ## forecast mean
#   Q  = array(NA, dim = c(rr,rr,tt))  ## forecast scale
#   m  = array(NA, dim = c(nn,   tt))  ## state posterior mean
#   C  = array(NA, dim = c(nn,nn,tt))  ## state posterior scale
#   
#   ## Initialisation
#   mt = m0
#   Ct = C0
#   
#   ## Loop over time
#   for (t in 1:tt) {
#     
#     ## Prediction step
#     at = G[,,t] %*% mt + d[,t]
#     Rt = G[,,t] %*% Ct %*% t(G[,,t]) + W[,,t]
#     ft = F[,,t] %*% at + c[,t]
#     Qt = F[,,t] %*% Rt %*% t(F[,,t]) + V[,,t]
#     
#     ## Update step
#     A = t(solve(Qt, F[,,t] %*% Rt))
#     e = y[,t] - ft
#     mt = at + A %*% e
#     Ct = Rt - A %*% Qt %*% t(A)
#     
#     ## Store results
#     m[, t] = mt
#     C[,,t] = Ct
#     a[, t] = at
#     R[,,t] = Rt
#     f[, t] = ft
#     Q[,,t] = Qt
#     
#   } ## t
#   
#   ## Return results
#   results = list(m = m, C = C, a = a, R = R, f = f, Q = Q,
#                  y = y, F = F, G = G, V = V, W = W, c = c, d = d, 
#                  m0 = m0, C0 = C0)
#   return(results)
# 
# }

## Forward filtering
filter.dlm = function(y, F, G, V, W, m0, C0, c = NULL, d = NULL) {
  
  ## Extract dimensions
  rr = nrow(y)
  tt = ncol(y)
  nn = ncol(F)

  ## Check constants  
  if (is.null(c))
    c = array(0, c(rr,tt))
  if (is.null(d))
    d = array(0, c(nn,tt))

  ## Initial conditions
  a1 = as.vector(G[,,1] %*% m0 + d[,1])
  R1 = G[,,1] %*% C0 %*% t(G[,,1]) + W[,,1]
  
  ## Re-index state arrays
  dd = cbind(d[,-1,drop=FALSE],0)
  GG = array(0, dim(G))
  GG[,,1:(tt-1)] = G[,,2:tt]
  WW = array(0, dim(W))
  WW[,,1:(tt-1)] = W[,,2:tt]
  
  ## Fit model
  model = FKF::fkf(a1, R1, dd, c, GG, F, WW, V, y)
  
  ## Return results
  list(m = model$att, C = model$Ptt, 
       a = model$at[,-(tt+1)], R = model$Pt[,,-(tt+1)],
       f = model$vt, Q = model$Ft, logLik = model$logLik,
       y = y, F = F, G = G, V = V, W = W, m0 = m0, C0 = C0, c = c, d = d)
  
}


# ## Compute log-likelihood
# logLik.dlm = function(object) {
#   
#   ## Expects the following inputs:
#   ## object - an object generated by filter.dlm()
#   
#   results = sapply(1:ncol(object$y), function(t)
#     mnormt::dmnorm(object$y[,t], object$f[,t], 
#                    0.5*(object$Q[,,t]+t(object$Q[,,t])), TRUE))
#   
#   ## Return result
#   return(results)
#   
# }

## Compute log-likelihood
logLik.dlm = function(object) {
  
  ## Expects the following inputs:
  ## object - an object generated by filter.dlm()
  
  object$logLik
  
}


## Backward smoothing
smooth.dlm = function(object) {
  
  ## Expects the following inputs:
  ## object - an object generated by filter.dlm()
  
  ## Dimensions
  tt = ncol(object$y)     ## Length of observation vector
  nn = length(object$m0)  ## Length of state vector
  
  ## Create arrays to store results
  at = array(NA, dim = c(nn,   tt))  ## state prior mean
  Rt = array(NA, dim = c(nn,nn,tt))  ## state prior scale matrix
  
  ## Final conditions
  at[, tt] = object$m[, tt]
  Rt[,,tt] = object$C[,,tt]
  
  ## Loop over remaining times
  for (t in (tt-1):1) {
    
    Bt = t(solve(object$R[,,t+1], object$G[,,t] %*% object$C[,,t]))
    
    at[, t] = object$m[, t] + Bt %*% (at[, t+1] - object$a[, t+1])
    Rt[,,t] = object$C[,,t] + Bt %*% (Rt[,,t+1] - object$R[,,t+1]) %*% t(Bt)
    
  }
  
  ## Return results
  results = list(at = at, Rt = Rt)
  return(results)
  
}


## Backward sampling
sample.dlm = function(object, n.samples = 1e3) {
  
  ## Dimensions
  tt = ncol(object$y)     ## Length of observation vector
  nn = length(object$m0)  ## Length of state vector
  
  ## Mean vector
  zero = rep(0, nn)
  
  ## Create arrays to store results
  theta = array(NA, dim = c(n.samples,nn,tt))
  
  ## Sample final state
  theta[,,tt] = MASS::mvrnorm(n.samples, object$m[,tt], object$C[,,tt])
  
  ## Loop over remaining times
  for (t in (tt-1):1) {
    
    B = t(solve(object$R[,,t+1], object$G[,,t] %*% object$C[,,t]))
    h = t(object$m[,t] + B %*% (t(theta[,,t+1]) - object$a[,t+1]))
    H = object$C[,,t] - tcrossprod(B %*% object$R[,,t+1], B)
    
    theta[,,t] = h + MASS::mvrnorm(n.samples, zero, H)
    
  } ## t
  
  ## Return results
  return(theta)
  
}


## Backward sampling (single sample)
sample0.dlm = function(object) {
  
  ## Dimensions
  tt = ncol(object$y)     ## Length of observation vector
  nn = length(object$m0)  ## Length of state vector
  
  ## Create arrays to store results
  theta = array(NA, dim = c(nn,tt))
  
  ## Sample final state
  theta[,tt] = MASS::mvrnorm(1, object$m[,tt], object$C[,,tt])
  
  ## Loop over remaining times
  for (t in (tt-1):1) {
    
    B  = t(solve(object$R[,,t+1], object$G[,,t] %*% object$C[,,t]))
    h  = object$m[,t] + B %*% (theta[,t+1] - object$a[,t+1])
    H  = object$C[,,t] - tcrossprod(B %*% object$R[,,t+1], B)
    
    theta[,t] = MASS::mvrnorm(1, h, H)
    
  } ## t
  
  ## Return results
  return(theta)
  
}


## Forecasting
forecast.dlm = function(F, G, V, W, c, d, m0, C0) {
  
  ## Dimensions
  rr = dim(F)[1]  ## Dimension of observation vector
  nn = dim(F)[2]  ## Length of state vector
  kk = dim(F)[3]  ## Forecast length
  
  ## Create arrays to hold forecasts
  a = array(0, dim = c(nn,kk))
  R = array(0, dim = c(nn,nn,kk))
  f = array(0, dim = c(rr,kk))
  Q = array(0, dim = c(rr,rr,kk))
  
  ## Initial state
  at = m0
  Rt = C0
  
  for (k in 1:kk) {
    
    ## Predict state
    at = G[,,k] %*% at + d[,k]
    Rt = G[,,k] %*% Rt %*% t(G[,,k]) + W[,,k]
    
    ## Forecast observations
    ft = F[,,k] %*% at + c[,k]
    Qt = F[,,k] %*% Rt %*% t(F[,,k]) + V[,,k]
    
    ## Store results
    a[, k] = at
    R[,,k] = Rt
    f[, k] = ft
    Q[,,k] = Qt
    
  } ## k
  
  ## Return results
  results = list(f = f, Q = Q, a = a, R = R)
  return(results)
  
}


## Simulation
sim.dlm = function(F, G, V, W, c, d, m0, C0, n.samples = 1e3) {
  
  ## Dimensions
  rr = dim(F)[1]  ## Dimension of observation vector
  nn = dim(F)[2]  ## Length of state vector
  kk = dim(F)[3]  ## Forecast length
  
  ## Create arrays to hold forecasts
  a = array(0, dim = c(n.samples,nn,kk))
  f = array(0, dim = c(n.samples,rr,kk))
  
  ## Mean vector
  nn0 = rep(0, nn)
  rr0 = rep(0, rr)
  
  ## Sample initial state
  at = MASS::mvrnorm(n.samples, m0, C0)
  
  for (k in 1:kk) {
    
    ## Sample new state
    at = t(G[,,k] %*% t(at) + d[,k]) + MASS::mvrnorm(n.samples, nn0, W[,,k])
    
    ## Sample new observation
    ft = t(F[,,k] %*% t(at) + c[,k]) + MASS::mvrnorm(n.samples, rr0, V[,,k])
    
    ## Store samples
    a[,,k] = at
    f[,,k] = ft
    
  } ## k

  ## Return results
  results = list(a = a, f = f)
  return(results)
  
}

## Simulation
sim0.dlm = function(F, G, V, W, c, d, m0, C0) {
  
  ## Dimensions
  rr = dim(F)[1]  ## Dimension of observation vector
  nn = dim(F)[2]  ## Length of state vector
  kk = dim(F)[3]  ## Forecast length
  
  ## Create arrays to hold forecasts
  a = array(0, dim = c(nn,kk))
  f = array(0, dim = c(rr,kk))
  
  ## Sample initial state
  at = MASS::mvrnorm(1, m0, C0)
  
  for (k in 1:kk) {
    
    ## Sample new state
    at = MASS::mvrnorm(1, G[,,k] %*% at + d[,k], W[,,k])
    
    ## Sample new observation
    ft = MASS::mvrnorm(1, F[,,k] %*% at + c[,k], V[,,k])
    
    ## Store samples
    a[,k] = at
    f[,k] = ft
    
  } ## k
  
  ## Return results
  results = list(a = a, f = f)
  return(results)
  
}
